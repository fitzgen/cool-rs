use crate::ast;
use crate::frontend::lexer;
use failure;

grammar<'input>(ctx: &mut ast::Context);

pub Program: Vec<ast::NodeId> = <Class+>;

SepList<T, S>: Vec<T> = {
    => vec![],
    <e:T> <v:(S <T>)*> => {
        let mut v = v;
        v.insert(0, e);
        v
    }
};

Type: ast::TypeIdentifier = <t:TypeToken> =>
    ctx.new_type_identifier(t);

Identifier: ast::Identifier = <i:IdentifierToken> =>
    ctx.new_identifier(i);

Class: ast::NodeId =
    "class" <t:Type> <parent:("inherits" <Type>)?> "{" <features:(<Feature> ";")*> "}" ";" => {
        ctx.new_class(t, parent, features)
    };

Feature: ast::NodeId = {
    <name:Identifier> "(" <formals:SepList<Formal, ",">> ")" ":" <t:Type> "{" <e:Expr<"yes">> "}" =>
        ctx.new_method(name, formals, t, e),
    <name:Identifier> ":" <t:Type> <e:("<-" <Expr<"yes">>)?> =>
        ctx.new_property(name, t, e),
};

Formal: (ast::Identifier, ast::TypeIdentifier) = <i:Identifier> ":" <t:Type> => (i, t);

Expr<AllowLet>: ast::NodeId = {
    <NotExpr<AllowLet>>,
    <i:Identifier> "<-" <e:Expr<AllowLet>> => ctx.new_assign(i, e),
};

NotExpr<AllowLet>: ast::NodeId = {
    <RelExpr<AllowLet>>,
    "not" <e:RelExpr<AllowLet>> => ctx.new_not(e),
};

RelExpr<AllowLet>: ast::NodeId = {
    <ArithExpr<AllowLet>>,
    <lhs:ArithExpr<"no">> "<=" <rhs:ArithExpr<AllowLet>> => ctx.new_less_than_equal(lhs, rhs),
    <lhs:ArithExpr<"no">> "<" <rhs:ArithExpr<AllowLet>> => ctx.new_less_than(lhs, rhs),
    <lhs:ArithExpr<"no">> "=" <rhs:ArithExpr<AllowLet>> => ctx.new_equal(lhs, rhs),
};

ArithExpr<AllowLet>: ast::NodeId = {
    <ProdExpr<AllowLet>>,
    <lhs:ArithExpr<"no">> "+" <rhs:ProdExpr<AllowLet>> => ctx.new_add(lhs, rhs),
    <lhs:ArithExpr<"no">> "-" <rhs:ProdExpr<AllowLet>> => ctx.new_sub(lhs, rhs),
};

ProdExpr<AllowLet>: ast::NodeId = {
    <IsVoidExpr<AllowLet>>,
    <lhs:ProdExpr<"no">> "*" <rhs:IsVoidExpr<AllowLet>> => ctx.new_mul(lhs, rhs),
    <lhs:ProdExpr<"no">> "/" <rhs:IsVoidExpr<AllowLet>> => ctx.new_div(lhs, rhs),
};

IsVoidExpr<AllowLet>: ast::NodeId = {
    <NegExpr<AllowLet>>,
    "isvoid" <e:NegExpr<AllowLet>> => ctx.new_isvoid(e),
};

NegExpr<AllowLet>: ast::NodeId = {
    <DotExpr<AllowLet>>,
    "~" <e:DotExpr<AllowLet>> => ctx.new_negate(e),
};

DotExpr<AllowLet>: ast::NodeId = {
    <SimpleExpr<AllowLet>>,
    <e:DotExpr<"no">> <c:("@" <Type>)?> "." <id:Identifier> "(" <args:SepList<Expr<"yes">, ",">> ")" =>
        ctx.new_dispatch(e, c, id, args),
};

SimpleExpr<AllowLet>: ast::NodeId = {
    <e:LetExpr> if AllowLet == "yes" => e,
    <id:Identifier> "(" <args:SepList<Expr<"yes">, ",">> ")" => {
        let receiver = ctx.new_identifier("self");
        let receiver = ctx.new_variable_reference(receiver);
        let cast = None;
        ctx.new_dispatch(receiver, cast, id, args)
    },
    "if" <condition:Expr<"yes">> "then" <consequent:Expr<"yes">> "else" <alternative:Expr<"yes">> "fi" =>
        ctx.new_if_then_else(condition, consequent, alternative),
    "while" <condition:Expr<"yes">> "loop" <body:Expr<"yes">> "pool" =>
        ctx.new_while(condition, body),
    "{" <es:(<Expr<"yes">> ";")+> "}" =>
        ctx.new_block(es),
    "case" <e:Expr<"yes">> "of" <cases:(<Identifier> ":" <Type> "=>" <Expr<"yes">> ";")+> "esac" =>
        ctx.new_case(e, cases),
    "new" <t:Type> =>
        ctx.new_new(t),
    "(" <e:Expr<"yes">> ")" =>
        e,
    <id:Identifier> =>
        ctx.new_variable_reference(id),
    <i:IntegerToken> =>
        ctx.new_integer_const(i),
    <s:StringToken> =>
        ctx.new_string_const(s),
    "true" =>
        ctx.new_bool_const(true),
    "false" =>
        ctx.new_bool_const(false),
};

LetExpr: ast::NodeId = {
    "let" <id:Identifier> ":" <ty:Type> <e:("<-" <Expr<"yes">>)?>
        <bindings:("," <Identifier> ":" <Type> <("<-" <Expr<"yes">>)?> )*>
        "in" <body:Expr<"yes">> => {
            let body = bindings.into_iter().rev().fold(body, |body, (id, ty, expr)| {
                ctx.new_let_in(id, ty, expr, body)
            });
            ctx.new_let_in(id, ty, e, body)
        }
};

extern {
    type Location = usize;
    type Error = failure::Error;

    enum lexer::Token<'input> {
        IntegerToken => lexer::Token::Integer(<i64>),
        IdentifierToken => lexer::Token::Identifier(<&'input str>),
        TypeToken => lexer::Token::Type(<&'input str>),
        StringToken => lexer::Token::String(<String>),

        // Keywords
        "class" => lexer::Token::Class,
        "else" => lexer::Token::Else,
        "false" => lexer::Token::False,
        "fi" => lexer::Token::Fi,
        "if" => lexer::Token::If,
        "in" => lexer::Token::In,
        "inherits" => lexer::Token::Inherits,
        "isvoid" => lexer::Token::Isvoid,
        "let" => lexer::Token::Let,
        "loop" => lexer::Token::Loop,
        "pool" => lexer::Token::Pool,
        "then" => lexer::Token::Then,
        "while" => lexer::Token::While,
        "case" => lexer::Token::Case,
        "esac" => lexer::Token::Esac,
        "new" => lexer::Token::New,
        "of" => lexer::Token::Of,
        "not" => lexer::Token::Not,
        "true" => lexer::Token::True,

        // Symbols
        "{" => lexer::Token::LeftCurly,
        "}" => lexer::Token::RightCurly,
        "(" => lexer::Token::LeftParen,
        ")" => lexer::Token::RightParen,
        ";" => lexer::Token::Semicolon,
        ":" => lexer::Token::Colon,
        "." => lexer::Token::Dot,
        "," => lexer::Token::Comma,
        "<-" => lexer::Token::Assign,
        "@" => lexer::Token::At,
        "+" => lexer::Token::Add,
        "-" => lexer::Token::Sub,
        "*" => lexer::Token::Mul,
        "/" => lexer::Token::Div,
        "~" => lexer::Token::Negate,
        "<" => lexer::Token::LessThan,
        "<=" => lexer::Token::LessThanEqual,
        "=" => lexer::Token::Equal,
        "=>" => lexer::Token::RightArrow,
    }
}
